package E1_daily;

import java.util.HashMap;

public class E326_MinimumSizeSubarrayInInfiniteArray {

    public static int minSizeSubarray(int[] nums, int target) {
        int n=nums.length;
        long curSum=0;
        int countCycle=0;
        boolean isExceedEnough=false;
        int isExceedEnoughCount=0;
        int start=0, end=0;
        int rs=Integer.MAX_VALUE;
        int size=0;
        long sum=0;

        //Without this ==> TLE
        for (int i = 0; i < n; i++) {
            sum+=nums[i];
        }
        if(target>=sum){
            curSum=(target/sum)*sum;
            size+=(target/sum)*n;
        }

        //nums = [1,2,3]
        //[1,2,3,1,2,3,1,2,...]
        while((isExceedEnoughCount<=2 || countCycle <= 2)){
            curSum+=nums[end];
            while (curSum>target&&start<n&&curSum>0){
                curSum-=nums[start];
                start=(start+1)%n;
                isExceedEnough=true;
                size--;
            }
            end=end+1;
            size++;
            if(end==n){
                countCycle++;
            }
            if(isExceedEnough){
                isExceedEnoughCount++;
            }
            end=end%n;
            if(curSum==target){
                rs=Math.min(rs, size);
            }
//            System.out.printf("%s %s, sum: %s, countCycle: %s, isExceedEnough: %s\n", start, end, curSum, countCycle, isExceedEnough);
        }
        return rs==Integer.MAX_VALUE?-1:rs;
    }

    public static int minSizeSubarrayMemo(int[] A, int target) {
        long sumA = 0L, su = 0L;
        for (int a : A)
            sumA += a;
        int n = A.length, k = (int)(target / sumA), res = n;
        //Đoạn này quan trọng khi mình chỉ cần mirror phần mod
        //+ Target = target % sum
        target %= sumA;
        //Nếu chia hết thì lấy phần dài nhất là được
        //+ (Target%sum) == 0
        if (target == 0) {
            return k * n;
        }

        HashMap<Long, Integer> dp = new HashMap<>();
        dp.put(0L, -1);

        //Phần còn lại làm như bình thường là được
        for (int i = 0; i < 2 * n; ++i) {
            su += A[i % n];
            if (dp.containsKey(su - target)) {
                res = Math.min(res, i - dp.get(su - target));
            }
            dp.put(su, i);
        }

        return res < n ? res + k * n : -1;
    }

    public static void main(String[] args) {
        //** Requirement
        //- You are given a 0-indexed array nums and an integer target.
        //- A 0-indexed array infinite_nums is generated by infinitely appending the elements of nums to itself.
        //* Return the length of (the shortest subarray) of the array infinite_nums with a sum equal to (target).
        // If there is no such subarray return -1.
        //
        //Example 2:
        //
        //Input: nums = [1,1,1,2,3], target = 4
        //Output: 2
        //Explanation: In this example infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...].
        //The subarray in the range [4,5], has the sum equal to target = 4 and length = 2.
        //It can be proven that 2 is the shortest length of a subarray with sum equal to target = 4.
        //
        //** Idea
        //1.
        //1.0,
        //- Method-1:
        //+ Constraints:
        //1 <= nums.length <= 10^5
        //1 <= nums[i] <= 10^5
        //1 <= target <= 10^9
        //  + nums.length <= 10^5 ==> Time: O(n*k)
        //  + target <= 10^9 ==> Long/ Binary search
        //
        //* Brainstorm:
        //- Make it simple without infinity
        //- val >0 ==> We can use slide window
        //- We can solve this without using (the prefix sum)
        //  + (3,2,1),6, target = 4
        //  ==> We can move 3,(2,1),6
        //- Infinitive:
        //  + When we stop the loop:
        //      + The number of clone >= 2
        //      + The sum of array is big enough
        //
        //
        //1.1, Case
        //
        //* TLE:
        //int[] nums ={1,1,1};
//        int target = 1000000000;
        //
        //** Without this ==> TLE
//        for (int i = 0; i < n; i++) {
//            sum+=nums[i];
//        }
//        if(target>=sum){
//            curSum=(target/sum)*sum;
//            size+=(target/sum)*n;
//        }
        //
        //1.2, Optimization
        //- Tăng cycle count ==> 3 (Để cover các special cases)
        //
        //Đoạn này quan trọng khi mình chỉ cần mirror phần mod
        //+ Target = target % sum
        //- target %= sumA;
        //Nếu chia hết thì lấy phần dài nhất là được
        //+ (Target%sum) == 0
        //if (target == 0) {
        //  return k * n;
        //}
        //HashMap<Long, Integer> dp = new HashMap<>();
        //dp.put(0L, -1);
        //* Phần còn lại làm như bình thường là được
        //
        //1.3, Complexity
        //- Space: O(n)
        //- Time: O(1)
//        int[] nums ={1,2,3};
//        int target = 5;
        //[1,1,1,2,3],[1,1,1,2,3]
//        int[] nums ={1,1,1,2,3};
//        int target = 4;
        int[] nums ={2,5,6,4};
        int target = 95;
//        int[] nums ={2,2,1,3,2,2,2,3,3,2,1,3,3,2,3,3};
//        int target = 93;
//        int[] nums ={1,1,1};
//        int target = 1000000000;
        System.out.println(minSizeSubarray(nums, target));
        System.out.println(minSizeSubarrayMemo(nums, target));
    }
}
